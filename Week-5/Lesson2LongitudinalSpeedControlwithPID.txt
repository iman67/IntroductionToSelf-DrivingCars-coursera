Welcome back. In the previous video, we briefly reviewed the design of PID controllers and classical controller design. In this video, we'll apply PID control to our longitudinal vehicle model. So, by the end of this video, you'll be able to; define the full vehicle planning and control architecture and design a PID-based controller for regulating to a set reference speed as in cruise control. Let's take a closer look at the vehicle control architecture and how it fits into the overall autonomy software stack. We can divide the structure into four sections. These sections are connected to each other. The first section is the perception of the road and the environment. This perception is captured by sensors and generates the input references for our system. In the second layer, we have both path generation and speed profile generation, which in automotive circles is referred to as the drive cycle. These profiles are generated through the motion planning process, which is the focus of the fourth course of this specialization. The path and the speed profiles are the reference inputs needed by our controllers. For longitudinal control, define the set point's, acceleration and deceleration that we'd like to be able to track precisely. For both the lateral and longitudinal control of an autonomous vehicle, the only task that needs to be performed is to follow the plan as precisely as possible, and thereby minimize the error between the actual and reference path and speed. All other tasks required for autonomous driving or done by other parts of the system. Finally, the controllers generate the input commands or actuator signals for the vehicle. As we've seen in the previous module, these include the steering for the lateral control and the throttle and break commands for longitudinal control. Let's look at an example of longitudinal vehicle control. One of the most well-known and commonly available control applications in automotive control is cruise control operating at highway speeds. A cruise control system performs the function of maintaining a fixed reference speed using throttle commands, and accelerating or decelerating to a new reference speed as requested by the driver. When the vehicle is subjected to different loads and resistances, the throttle angle will be changed by the cruise controller accordingly. Many systems now exist with expanded capabilities such as the adaptive cruise control, which can vary the reference point based on measurements of a lead vehicle and semi autonomous systems, like traffic jam assist, which can operate throughout the vehicle speed range and create spacing gaps for merging vehicles. These extended examples require additional controller designed to handle the wider range of operating points. This block diagram shows the cruise controller and plant vehicle model as a closed loop system designed to keep the vehicle velocity close to the reference velocity. The controller can be split into two levels; a high level and a low level controller. Although the low level controller is not essential to the control task. The high level controller takes the difference between the set point velocity and the vehicle actual velocity, and generates the desired vehicle acceleration to close the gap. The low-level controller gets the vehicle acceleration and generates a throttle or breaking actuation to track the reference acceleration. In practice, this two-stage approach allows us to go beyond just PID control and impose limits or profiles directly on the accelerations that are requested of the vehicle in order to maintain speed. It also allows us to separate the use of engine maps we studied in the previous module for generating a desired torque given the engine state from the cruise control input response. Let's take a closer look at the high level controller. The upper level or high level controller determines how much acceleration is needed at each time step based on the velocity error. Let's apply a PID controller here, which is expressed in the continuous time domain. The input to the high level controller is the velocity error, and the output is the vehicle's desired acceleration. In the previous lesson, we learned how to design a PID controller and studied how the different gains affect performance of the controller. To implement such a controller in software, we discretize the controller, changing the integral to a summation over a fixed length time steps. The derivative term can be approximated with the finite difference over a fixed time step if either the reference acceleration or the estimated vehicle acceleration is not available. The low-level controller generates the throttle and breaking signals to follow the desired acceleration calculated by the high-level controller. In designing a low-level controller, we make some assumptions to simplify our problem. We assume that only throttle is needed to manage the speed of the vehicle during cruise control, and that the driver will take over if breaking is required to avoid an incident. We assume that we are operating in gear three or higher such that the torque converter is locked, meaning that torque from the engine passes directly through the transmission without loss, and we assume that the tire slip angle and ratio are negligible as cruise control motions are typically gentle. The low-level controllers seeks to generate the desired acceleration from the high level controller by increasing or decreasing the torque produced by the engine. This is controlled by the throttle angle, but is governed by the power train dynamics and the engine map, making it a nonlinear problem that can be a challenge for classic control methods. Instead, the desired acceleration is translated to a torque demand, and the torque demand is then converted to a throttle angle command. Recall from the previous module that we developed a second-order ordinary differential equation to describe the acceleration of the vehicle in terms of the difference between the engine torque and the load torque. We can rearrange this equation to solve for the desired engine torque, given known load torques and the desired acceleration of the vehicle. Then, the steady-state engine map, which is generated in testing the engine at different operating points can be used to determine the throttle angle needed to produce the amount of torque demand required. In these standard maps, the desired engine torque and the current engine RPM define the required throttle position, and can be interpolated if needed. This approach is a data-driven approximation, but it works quite well in practice. The approximation comes from the fact that the data points in the map are steady-state points while the power train is continuously changing its operating point to meet the current driving conditions. Finally, we can put the pieces of our vehicle controller together and simulate the control response to a step change in desired speed of our dynamic vehicle models with PID controllers. The PID gains are tuned by trial and error so that the vehicle speeds follow the reference velocity of 30 meters per second or a 108 kilometers per hour. In the results plot, on the left, we see the throttle opening as a percentage, which is the commanded throttle for the vehicle. On the right, we see how the actual velocity evolves over time, and reaches the reference velocity after a settling time. Because of the engine map non-linearity, we see some interesting artifacts in the vehicle response as it closes in on the reference speed. You'll see even more interesting effects in the simulated vehicles in Carla during your final assessment for this course, with gear changes causing big challenges for pure PID control. In this video, we covered the concept of longitudinal speed control for a cruise control system. This is the first case in designing a controller for the autonomous car to follow a desired forward speed in this course. We learned the concepts of high-level and low-level controllers and use the combination of PID control and engine maps to regulate vehicle speed. In the next video, you will learn how to apply feed-forward control to improve the performance of a longitudinal control system. See you there.